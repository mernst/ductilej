TypelessJ TODO
--------------

- Create a PathedTreeTranslator which keeps the path around and provides
  methods for querying path structure; use that to determine whether or not we
  should transform a JCFieldAccess

Open issues
- How to handle switch (can't just switch ((Integer)exp) because of enums)?
-- Transform into a for{} and some if()s?
- How to handle post-fix assignment operators (++, +=, etc.)?
-- Implement mutable boxes, ensure that all "initially primitive" variables
reference mutable boxes and preserve mutable boxes through operations
- What math ops are legal for Character (+ and -, but * and /?)
- What to do about exceptions?
-- We either don't detype them (but then throwing the result of a function call breaks)
-- If we cast them to Exception (or Throwable) then the method has to declare
that it throws that exception (we could adjust all method declarations to throw
Exception but that won't work for library overriders)
-- We could wrap the exception in RuntimeException but that breaks semantics
and will also anger javac if it sees a try/catch on a checked exception that is
not thrown
-- Maybe we don't detype them (or rather we immediately cast back to the type
provided in the new expression), and we don't detype the return value of any
method that returns an Exception subclass?

Detyper
- Handle field dereference (foo.bar)
- Handle array creation (new type[expr] -> new type[(Integer)expr])
- Handle array cell assignment (foo[bar] = baz)
- Insert cast to proper return type for overridden library methods
- I think we don't need to annotate anonymous inner classes, confirm this
- Implement signature mangling
- Need to handle static imports (hopefully we won't need to differentiate
between members and methods)
- Extract main() detection into ASTUtil, make it correct
- Record original type information when transforming JCVariableDecl, somehow
pass that along to all runtime methods so that they can provide better feedback
- Record original type information when transforming JCMethodDecl and store
that in annotations preserved at runtime for use by RT.invoke()

Runtime
- Finish implementation of RT.unop(), RT.binop()
- Make use of type information everywhere possible to validate types before
calling typed library methods (transformed methods as well)

Later
- Maybe implement rudimentary scoping:
-- track all names visible at each scope and use that to determine if global
names are shadowed
-- if we want to get crazy we can also keep some unresolved type information
around for the names
